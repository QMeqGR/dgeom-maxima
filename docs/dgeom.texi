\input texinfo   @c -*-texinfo-*-

@setfilename dgeom.info
@settitle Package dgeom

@ifinfo
@macro var {expr}
<\expr\>
@end macro
@end ifinfo

@dircategory Mathematics/Maxima
@direntry
* Package dgeom: (maxima) Maxima share package dgeom
@end direntry

@menu
* Introduction to package dgeom::
* Functions and Variables for dgeom::
@end menu
@node Top, Introduction to package dgeom, (dir), (dir)
@top


@menu
* Introduction to package dgeom::
* Functions and Variables for dgeom::

@detailmenu
 --- The Detailed Node Listing ---

* Introduction to package dgeom::
* Functions and Variables for dgeom::

@end detailmenu
@end menu


@chapter Package dgeom

@node Introduction to package dgeom, Functions and Variables for dgeom, Top, Top
@section Introduction to package dgeom

The @code{dgeom} package provides some basic functions useful for
exploring metrics and manifolds. In particular coordinate
transformations that allow one to define embedded manifolds in flat
space. But the package provides more general tools for computing metrics
after a coordinate transformation. This package was designed to be
compatible with the @code{ctensor} package included with Maxima.
The @code{dgeom} package computes the frame field connections for an
embedded surface using frames defined by the attitude matrix.

The basic use of the package begins by defining the coordinates in the
variables @code{cords_in}, @code{cords_tr}, and @code{cords_ot}. This
can be done manually or by using the built-in function @code{dg_cords}.

In a typical session, one should first call @code{dg_cords(all)} to see
the available coordinate systems and then choose one, or set up the
coordinates by hand. Second, call @code{dg_metric()} to compute the
metric in the new coordinates.  @code{dgeom} can calculate the
divergence, gradient, and Laplacian in any coordinate system you can
define. It also defines them as functions you can then call if you want
to use them in a computation.  These computations are available in the
functions @code{dg_diverg()}, @code{dg_grad()}, and @code{dg_laplac()}.

If the frame field connections are desired, call @code{dg_ffc()}. Note
that @code{dgeom} can also compute a new metric from an old metric where
the old metric is not @math{\delta} (identity) or @math{\eta}
(Minkowski).

The @code{dgeom} package can also compute the Killing vector equations
from the metric.

Note: It helps to simplify the resulting formulas by restricting
coordinate ranges. For example, if studying the sphere one should use
@code{assume(theta>0,theta<%pi)} and @code{assume(r>0)}. These are set
automatically in the package, but for coordinate systems input by hand
one should consider setting the ranges manually.

The @code{dgeom} package is compatible with the @code{ctensor}
package. Coordinates defined in @code{dgeom} can be used for
computations in the @code{ctensor} package such as the Christoffel
symbols, the Riemann tensor and so forth. See the function
@code{set_ctensor_vars} for more information.

@node Functions and Variables for dgeom, , Introduction to package dgeom, Top
@section Functions and Variables for dgeom

@defvr {Variable} cord_in
Input coordinates are given as a list in the variable @code{cord_in}.
@end defvr

@defvr {Variable} cord_ot
Output coordinates are given as a list in the variable @code{cord_ot}.
@end defvr

@defvr {Variable} cord_tr
Coordinate transformations are given as a list in the variable @code{cord_tr}.
@code{cord_tr:[r*sin(theta)*cos(phi),r*sin(theta)*sin(phi),r*cos(theta)]}.
@end defvr

@defvr {Variable} dg_minkowski
The variable @code{dg_minkowski} (default value: 1) determines whether
the metric in the output coordinates @code{cords_ot} is computed with a
Minkowski signature. This variable is set automatically for the
predefined coordinate transformations 'rindler'. If defining coordinates
in Minkowski signature without using the function @code{dg_cords}, the
timelike coordinate must be the first element in the list for both
@code{cords_in} and @code{cords_ot}.
@end defvr

@anchor{dg_cords}
@deffn {Function} dg_cords (@var{coordinate system})
The function @code{dg_cords} takes a predefined coordinate system name
and sets the variables @code{cords_in}, @code{cords_tr},
@code{cords_ot}.  @code{cords_in} are the input coordinates,
@code{cords_tr} are the transformation functions to the new or output
coordinates, and @code{cords_ot} are the output coordinates.  To see the
available predefined coordinate systems use @code{dg_cords(all)}.
@end deffn

@example
@group
(%i1) dg_cords(rindler); 
(%o1)                                done
(%i2) show_cords(); 
                               cords_in = [t, x]

                 cords_tr = [sinh(omega) rho, cosh(omega) rho]

                            cords_ot = [omega, rho]

                              dg_minkowski = - 1

(%o2)                                done
(%i3) dg_metric(init); 
                                      2         2
                          ds2_in = del (x) - del (t)

                               2           2    2
                      ds2 = del (rho) - rho  del (omega)

(%o3)                                done
@end group
@end example

@anchor{show_cords}
@deffn {Function} show_cords ( )
The function @code{show_cords} takes no arguments. It displays the
variables @code{cord_in}, @code{cord_tr}, @code{cord_ot}, and
@code{dg_minkowski}.
@end deffn

@anchor{dg_derivs} 
@deffn {Function} dg_derivs ( )
This function takes no arguments, but the input and output coordinates
and the transformation functions must be defined beforehand for this
function to work. See the function @ref{dg_cords}.  The function
@code{dg_derivs} computes the partial derivative functions of the output
coordinates in terms of the input coordinates using the transformation
functions. For example, for input coordinates @code{[x,y,z]}, and output
coordinates @code{[r,phi,z]}, and using the predefined cylindrical
coordinate transformation @code{xyz_to_cyl}, one obtains the partial
derivatives with respect to @var{(x,y,z)} in terms of the partial
derivatives with respect to the variables @var{(r,phi,z)}.

The resulting partial derivative functions are named according to the
input variable names, in the following notation. The partial derivative
with respect to @var{x} is denoted @code{d_dx}, and likewise for the
other input coordinates. The functions are defined with argument names
generated by @code{gensym}.
@end deffn

@example
@group
(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_derivs(); 
(%o2)                                done
(%i3) fundef(d_dx); 
                                dF             dF
(%o3)               d_dx(F) := ---- sin(phi) + -- cos(phi)
                               dphi            dr
@end group
@end example

@anchor{dg_metric}
@deffn {Function} dg_metric ([init,cnvrt])
This function takes as argument @var{init} or @var{cnvrt}. The input and
output coordinates and the transformation functions must be defined
beforehand for this function to work. See the function @ref{dg_cords}.
The function @code{dg_metric} computes the metric in terms of the output
coordinates @code{cords_ot}. If @code{dg_metric} is called with the
argument @var{init} then the function assumes the input metric is
diagonal with unit entries, although @code{dg_minkowski} may be set to
-1 for the time component. If @code{dg_metric} is called with the
argument @var{cnvrt}, then the function assumes there is an initial
metric given in the matrix @code{lg_in} with the ordering of the entries
in accordance with the ordering of the variables in @code{cords_in}. The
value of @code{dg_minkowski} is ignored for this case. @code{dg_metric}
returns the line element @var{ds@sup{2}} in the variable @code{ds2}, and
the metric in the matrix @code{g}.
@end deffn

@example
@group
(%i1) dg_cords(xyz_to_spher); 
(%o1)                                done
(%i2) dg_metric(init); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                  2    2             2       2    2           2
           ds2 = r  del (theta) + del (r) + r  sin (theta) del (phi)

(%o2)                                done
@end group
@end example

The following example illustrates the conversion of the Rindler metric
to new coordinates that mimic the Schwarzschild metric.

@example
@group
(%i1) cords_in:[omega,rho]; 
(%o1)                            [omega, rho]
(%i2) cords_ot:[t,xi]; 
(%o2)                               [t, xi]
(%i3) cords_tr:[t/2,2*sqrt(xi)]; 
                                 t
(%o3)                           [-, 2 sqrt(xi)]
                                 2
(%i4) lg_in:matrix([-rho^2,0],[0,1]); 
                                 [      2    ]
(%o4)                            [ - rho   0 ]
                                 [           ]
                                 [   0     1 ]
(%i5) dg_metric(cnvrt); 
                                 2           2    2
                     ds2_in = del (rho) - rho  del (omega)

                                   2
                                del (xi)         2
                          ds2 = -------- - xi del (t)
                                   xi

(%o5)                                done
@end group
@end example

@anchor{dg_grad}
@deffn {Function} dg_grad ( )
This function takes no arguments. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function @ref{dg_cords}. The function
@code{dg_grad} returns an expression for the gradient of a function
@code{F} in the output coordinates @code{cord_ot}.
@end deffn

@example
@group
(%i1) dg_cords(xyz_to_spher); 
(%o1)                                done
(%i2) dg_grad(); 
                             dF             dF
                            ---- e_phi    ------ e_theta
                            dphi          dtheta           dF
(%o2)         dg_gra(F) := ------------ + -------------- + -- e_r
                           r sin(theta)         r          dr
@end group
@end example

@anchor{dg_curl}
@deffn {Function} dg_curl ( )
This function takes no arguments. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function @ref{dg_cords}.

The function @code{dg_curl} returns a function @code{dg_cur(W)} that
takes vector argument @code{W} and returns the curl in terms of the
output coordinates @code{cord_ot}.
@end deffn

@example
@group
(%i1) dg_cords(cart3d); 
(%o1)                                done
(%i2) dg_curl(); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                                2         2         2
                       ds2 = del (z) + del (y) + del (x)

                                 dW_z   dW_y  dW_x   dW_z  dW_y   dW_x
(%o2)  dg_cur(W_x, W_y, W_z) := [---- - ----, ---- - ----, ---- - ----]
                                  dy     dz    dz     dx    dx     dy
(%i3) dg_cords(xyz_to_cyl); 
(%o3)                                done
(%i4) dg_curl(); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                             2         2       2    2
                    ds2 = del (z) + del (r) + r  del (phi)

                                  dW_z
                                  ----
                                  dphi   dW_phi  dW_r   dW_z
(%o4) dg_cur(W_r, W_phi, W_z) := [---- - ------, ---- - ----, 
                                   r       dz     dz     dr
                                                         dW_r
                                                         ----
                                                         dphi   W_phi   dW_phi
                                                       - ---- + ----- + ------]
                                                          r       r       dr
@end group
@end example

@anchor{dg_diverg}
@deffn {Function} dg_diverg ( )
This function takes no arguments. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function @ref{dg_cords}.

The function @code{dg_diverg} returns a function @code{dg_div(W)} that
takes argument @code{W} and returns the divergence in terms of the
output coordinates @code{cord_ot}. The function @code{dg_metric} must be
called before calling @code{dg_diverg}.
@end deffn

@example
@group
(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_metric(init); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                             2         2       2    2
                    ds2 = del (z) + del (r) + r  del (phi)

(%o2)                                done
(%i3) dg_diverg(); 
                                        W_r   dW_z   dW_r   dW_phi
(%o3)        dg_div(W_r, W_phi, W_z) := --- + ---- + ---- + ------
                                         r     dz     dr     dphi
@end group
@end example


@anchor{dg_laplac}
@deffn {Function} dg_laplac ( )
This function takes no arguments. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function @ref{dg_cords}.

The function @code{dg_laplac} returns a function @code{dg_lap(W)} that
takes arument @code{W} and returns the Laplacian in terms of the output
coordinates @code{cord_ot}. The function @code{dg_metric} must be called
before calling @code{dg_laplac}.
@end deffn

@example
@group
(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_metric(init); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                             2         2       2    2
                    ds2 = del (z) + del (r) + r  del (phi)

(%o2)                                done
(%i3) dg_laplac(); 
                                 2     2                 2
                                d F   d F   2   dF      d F
                               (--- + ---) r  + -- r + -----
                                  2     2       dr         2
                                dz    dr               dphi
(%o3)             dg_lap(F) := -----------------------------
                                             2
                                            r
@end group
@end example


@anchor{dg_ffc}
@deffn {Function} dg_ffc (@var{[constraint equations]})
Compute the frame field connections. The input and output coordinates
and the transformation functions must be defined beforehand for this
function to work. See the function @ref{dg_cords}.

The function @code{dg_ffc} computes the attitude matrix @code{A}, the
connection coefficients in the matrix @code{Omega}, and the dual 1-forms
in the array @code{thi}. Any constraint equations given are imposed after
calculating the attitude matrix.

The structural equations are computed by first computing the matrices
@code{TT[i,j]: thi[i] . thi[j]}, and @code{DD[i,j]: diff(Omega[i,j])},
and then computing @code{KK[i,j]} by solving
@var{domega(i,j) = K th(i) * thi(j)}.
@end deffn

@example
@group
(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_ffc([r = 1]); 
(%o2)                                done
(%i3) A; 
                          [  cos(phi)   sin(phi)  0 ]
                          [                         ]
(%o3)                     [ - sin(phi)  cos(phi)  0 ]
                          [                         ]
                          [     0          0      1 ]
(%i4) Omega; 
                          [     0       del(phi)  0 ]
                          [                         ]
(%o4)                     [ - del(phi)     0      0 ]
                          [                         ]
                          [     0          0      0 ]
(%i5) thi; 
                                [   del(r)   ]
                                [            ]
(%o5)                           [ r del(phi) ]
                                [            ]
                                [   del(z)   ]
@end group
@end example

@anchor{dg_kill}
@deffn {Function} dg_kill ([none,show])
The function @code{dg_kill} computes the Killing equations. The metric
must be computed with @code{dg_metric} before this function is called.
If called with @code{dis=show} then the killing equations will be shown,
otherwise they can be accessed in the array @code{killeq}.
@end deffn

@example
@group
(%i1) dg_cords(mink2d); 
(%o1)                                done
(%i2) dg_metric(init); 
                                      2         2
                          ds2_in = del (x) - del (t)

                                     2         2
                            ds2 = del (x) - del (t)

(%o2)                                done
(%i3) dg_kill(show); 
                                            d     t
                          killeq     = - 2 (-- (xi ))
                                1, 1        dt

                                    d     x    d     t
                       killeq     = -- (xi ) - -- (xi )
                             1, 2   dt         dx

                                           d     x
                           killeq     = 2 (-- (xi ))
                                 2, 2      dx

(%o3)                                done
@end group
@end example


@anchor{get_ctensor_vars}
@deffn {Function} get_ctensor_vars ( )
This command is used to set the @code{dgeom} coordinate variables from
those defined in the @code{ctensor} package.  This command sets the
@code{dgeom} coordinate variable @code{cord_ot} to the ctensor variable
@code{ct_cords}. Then sets the lower indexed metric @code{lg} to the
metric @code{g}. The @code{ctensor} package must be loaded and the
metric computed for this command to work.
@end deffn

@anchor{set_ctensor_vars}
@deffn {Function} set_ctensor_vars ([init,cnvrt])
This function takes as argument @var{init} or @var{cnvrt}. The input and
output coordinates and the transformation functions must be defined
beforehand for this function to work. See the function @ref{dg_cords}.
See @ref{dg_metric} for a description of the options @var{init} and
@var{cnvrt}.  This command is used to set up the calculation of the
Christoffel symbols using the @code{ctensor} package using the
coordinates and transformation functions from the @code{dgeom}
package. The Christoffel symbols are the connections in the coordinate
frame, as opposed to the frame-field connection coefficients computed
using the function @code{dg_ffc}. The function @code{set_ctensor_vars}
sets the following @code{ctensor} variables: @code{cframe_flage:false},
@code{dim}, and calls @code{ct_coordsys()}. The @code{ctensor} package
must be loaded for this command to work.
@end deffn

Example: Compute the Christoffel symbols for flat space in polar
coordinates.

@example
@group
(%i1) load(ctensor)$ 
(%i2) dg_cords(xy_to_polar); 
(%o2)                                done
(%i3) set_ctensor_vars(init); 
                                      2         2
                          ds2_in = del (y) + del (x)

                               2    2             2
                        ds2 = r  del (theta) + del (r)

               ctlist = [r cos(theta), r sin(theta), [r, theta]]

(%o3)                                done
(%i4) christof(mcs); 
                                     2      1
(%t4)                             mcs     = -
                                     1, 2   r

                                    1
(%t5)                            mcs     = - r
                                    2, 2

(%o5)                                done
@end group
@end example


@node Function and Variable Index, , Top, Top
@appendix Function and Variable index
@printindex fn
@printindex vr

@bye
