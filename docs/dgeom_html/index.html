<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Top (Package dgeom)</title>

<meta name="description" content="Top (Package dgeom)">
<meta name="keywords" content="Top (Package dgeom)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="../dir_html/index.html" rel="up" title="(dir)">
<link href="#Introduction-to-package-dgeom" rel="next" title="Introduction to package dgeom">
<link href="../dir_html/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">



<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-dgeom" accesskey="n" rel="next">Introduction to package dgeom</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<a class="top" id="SEC_Top"></a>



<ul class="mini-toc">
<li><a href="#Package-dgeom" accesskey="1">Package dgeom</a></li>
<li><a href="Function-and-Variable-Index.html" accesskey="2">Function and Variable index</a></li>
</ul>
<div class="chapter-level-extent" id="Package-dgeom">
<h2 class="chapter"><span>1 Package dgeom<a class="copiable-link" href="#Package-dgeom"> &para;</a></span></h2>

<ul class="mini-toc">
<li><a href="#Introduction-to-package-dgeom" accesskey="1">Introduction to package dgeom</a></li>
<li><a href="#Functions-and-Variables-for-dgeom" accesskey="2">Functions and Variables for dgeom</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-package-dgeom">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-dgeom" accesskey="n" rel="next">Functions and Variables for dgeom</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-package-dgeom-1"><span>1.1 Introduction to package dgeom<a class="copiable-link" href="#Introduction-to-package-dgeom-1"> &para;</a></span></h3>

<p><em class="emph">Note: This package does not contain support for differential
forms. The &rsquo;cartan&rsquo; package in core Maxima provides some basic support
for forms. This package should be considered an add-on to the &rsquo;ctensor&rsquo;
package in core Maxima, providing further functionality for some tensor
calculations, as well as some standard differential geometry tools.</em>
</p>
<p>&nbsp;</p>
<p>The <code class="code">dgeom</code> package provides some basic functions useful for
exploring metrics and manifolds. In particular coordinate
transformations that allow one to define embedded manifolds in flat
space. The package also provides more general tools for computing
metrics after a coordinate transformation. This package was designed to
be compatible with the <code class="code">ctensor</code> package included with core Maxima.
</p>
<p>Major capabilities of <code class="code">dgeom</code> include:
</p><ul class="itemize mark-bullet">
<li>The <code class="code">dgeom</code> package computes the frame field connections for an
embedded surface using frames defined by the attitude matrix. See the
function <code class="code">dg_ffc()</code>.
</li><li>Computation a new metric from an old metric where the old metric is not
<em class="math">\delta</em> (identity) or <em class="math">\eta</em> (Minkowski). This is especially
useful for stringing together several coordinate transformations when
studying a metric.
</li><li>Computation of the Killing vector equations from the metric using
<code class="code">dg_kill()</code>.
</li></ul>

<p>The basic use of the package begins by defining the coordinates in the
variables <code class="code">cords_in</code>, <code class="code">cords_tr</code>, and <code class="code">cords_ot</code>. This
can be done manually or by using the built-in function <code class="code">dg_cords</code>.
</p>
<p>In a typical session, one should first call <code class="code">dg_cords(all)</code> to see
the available coordinate systems and then choose one, or set up the
coordinates by hand. Second, call <code class="code">dg_metric()</code> to compute the
metric in the new coordinates.  <code class="code">dgeom</code> can calculate the
divergence, gradient, curl (<code class="code">d=3</code> only), and Laplacian in any
coordinate system you can define. It also defines them as functions you
can then call if you want to use them in a computation.  These
computations are available in the functions <code class="code">dg_diverg()</code>,
<code class="code">dg_grad()</code>, <code class="code">dg_curl()</code>, and <code class="code">dg_laplac()</code>.
</p>
<p>Note: It helps to simplify the resulting formulas by restricting
coordinate ranges. For example, if studying the sphere one should use
<code class="code">assume(theta&gt;0,theta&lt;%pi)</code> and <code class="code">assume(r&gt;0)</code>. These are set
automatically in the package, but for coordinate systems input by hand
one should consider setting the ranges manually.
</p>
<p>The <code class="code">dgeom</code> package is compatible with the <code class="code">ctensor</code>
package. Coordinates defined in <code class="code">dgeom</code> can be used for
computations in the <code class="code">ctensor</code> package such as the Christoffel
symbols, the Riemann tensor and so forth. See the function
<code class="code">set_ctensor_vars</code> for more information.
</p>
<p>version: 0.1
</p>
<p>Eric Majzoub, Jan 2026
</p>
<hr>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-dgeom">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-package-dgeom" accesskey="p" rel="prev">Introduction to package dgeom</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-dgeom-1"><span>1.2 Functions and Variables for dgeom<a class="copiable-link" href="#Functions-and-Variables-for-dgeom-1"> &para;</a></span></h3>

<dl class="first-defvr def-block">
<dt class="defvr def-line" id="index-cord_005fin"><span class="category-def">Variable: </span><span><strong class="def-name">cord_in</strong><a class="copiable-link" href="#index-cord_005fin"> &para;</a></span></dt>
<dd><p>Input coordinates are given as a list in the variable <code class="code">cord_in</code>.
</p></dd></dl>

<dl class="first-defvr def-block">
<dt class="defvr def-line" id="index-cord_005fot"><span class="category-def">Variable: </span><span><strong class="def-name">cord_ot</strong><a class="copiable-link" href="#index-cord_005fot"> &para;</a></span></dt>
<dd><p>Output coordinates are given as a list in the variable <code class="code">cord_ot</code>.
</p></dd></dl>

<dl class="first-defvr def-block">
<dt class="defvr def-line" id="index-cord_005ftr"><span class="category-def">Variable: </span><span><strong class="def-name">cord_tr</strong><a class="copiable-link" href="#index-cord_005ftr"> &para;</a></span></dt>
<dd><p>Coordinate transformations are given as a list in the variable <code class="code">cord_tr</code>.
<code class="code">cord_tr:[r*sin(theta)*cos(phi),r*sin(theta)*sin(phi),r*cos(theta)]</code>.
</p></dd></dl>

<dl class="first-defvr def-block">
<dt class="defvr def-line" id="index-dg_005fminkowski"><span class="category-def">Variable: </span><span><strong class="def-name">dg_minkowski</strong><a class="copiable-link" href="#index-dg_005fminkowski"> &para;</a></span></dt>
<dd><p>The variable <code class="code">dg_minkowski</code> (default value: 1) determines whether
the metric in the output coordinates <code class="code">cords_ot</code> is computed with a
Minkowski signature. This variable is set automatically for the
predefined coordinate transformations &rsquo;rindler&rsquo;. If defining coordinates
in Minkowski signature without using the function <code class="code">dg_cords</code>, the
timelike coordinate must be the first element in the list for both
<code class="code">cords_in</code> and <code class="code">cords_ot</code>.
</p></dd></dl>

<a class="anchor" id="dg_005fcords"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fcords"><span class="category-def">Function: </span><span><strong class="def-name">dg_cords</strong> <var class="def-var-arguments">(<var class="var">coordinate system</var>)</var><a class="copiable-link" href="#index-dg_005fcords"> &para;</a></span></dt>
<dd><p>The function <code class="code">dg_cords</code> takes a predefined coordinate system name
and sets the variables <code class="code">cords_in</code>, <code class="code">cords_tr</code>,
<code class="code">cords_ot</code>.  <code class="code">cords_in</code> are the input coordinates,
<code class="code">cords_tr</code> are the transformation functions to the new or output
coordinates, and <code class="code">cords_ot</code> are the output coordinates.  To see the
available predefined coordinate systems use <code class="code">dg_cords(all)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(rindler); 
(%o1)                                done
(%i2) show_cords(); 
                               cords_in = [t, x]

                 cords_tr = [sinh(omega) rho, cosh(omega) rho]

                            cords_ot = [omega, rho]

                              dg_minkowski = - 1

(%o2)                                done
(%i3) dg_metric(init); 
                                      2         2
                          ds2_in = del (x) - del (t)

                               2           2    2
                      ds2 = del (rho) - rho  del (omega)

(%o3)                                done
</pre></div></div>

<a class="anchor" id="show_005fcords"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-show_005fcords"><span class="category-def">Function: </span><span><strong class="def-name">show_cords</strong> <var class="def-var-arguments">( )</var><a class="copiable-link" href="#index-show_005fcords"> &para;</a></span></dt>
<dd><p>The function <code class="code">show_cords</code> takes no arguments. It displays the
variables <code class="code">cord_in</code>, <code class="code">cord_tr</code>, <code class="code">cord_ot</code>, and
<code class="code">dg_minkowski</code>.
</p></dd></dl>

<a class="anchor" id="dg_005fderivs"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fderivs"><span class="category-def">Function: </span><span><strong class="def-name">dg_derivs</strong> <var class="def-var-arguments">( )</var><a class="copiable-link" href="#index-dg_005fderivs"> &para;</a></span></dt>
<dd><p>This function takes no arguments, but the input and output coordinates
and the transformation functions must be defined beforehand for this
function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>.  The function
<code class="code">dg_derivs</code> computes the partial derivative functions of the output
coordinates in terms of the input coordinates using the transformation
functions. For example, for input coordinates <code class="code">[x,y,z]</code>, and output
coordinates <code class="code">[r,phi,z]</code>, and using the predefined cylindrical
coordinate transformation <code class="code">xyz_to_cyl</code>, one obtains the partial
derivatives with respect to <var class="var">(x,y,z)</var> in terms of the partial
derivatives with respect to the variables <var class="var">(r,phi,z)</var>.
</p>
<p>The resulting partial derivative functions are named according to the
input variable names, in the following notation. The partial derivative
with respect to <var class="var">x</var> is denoted <code class="code">d_dx</code>, and likewise for the
other input coordinates. The functions are defined with argument names
generated by <code class="code">gensym</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_derivs(); 
(%o2)                                done
(%i3) fundef(d_dx); 
                                dF             dF
(%o3)               d_dx(F) := ---- sin(phi) + -- cos(phi)
                               dphi            dr
</pre></div></div>

<a class="anchor" id="dg_005fmetric"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fmetric"><span class="category-def">Function: </span><span><strong class="def-name">dg_metric</strong> <var class="def-var-arguments">([init,cnvrt])</var><a class="copiable-link" href="#index-dg_005fmetric"> &para;</a></span></dt>
<dd><p>This function takes as argument <var class="var">init</var> or <var class="var">cnvrt</var>. The input and
output coordinates and the transformation functions must be defined
beforehand for this function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>.
The function <code class="code">dg_metric</code> computes the metric in terms of the output
coordinates <code class="code">cords_ot</code>. If <code class="code">dg_metric</code> is called with the
argument <var class="var">init</var> then the function assumes the input metric is
diagonal with unit entries, although <code class="code">dg_minkowski</code> may be set to
-1 for the time component. If <code class="code">dg_metric</code> is called with the
argument <var class="var">cnvrt</var>, then the function assumes there is an initial
metric given in the matrix <code class="code">lg_in</code> with the ordering of the entries
in accordance with the ordering of the variables in <code class="code">cords_in</code>. The
value of <code class="code">dg_minkowski</code> is ignored for this case. <code class="code">dg_metric</code>
returns the line element <var class="var">ds<sup class="sup">2</sup></var> in the variable <code class="code">ds2</code>, and
the metric in the matrix <code class="code">g</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(xyz_to_spher); 
(%o1)                                done
(%i2) dg_metric(init); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                  2    2             2       2    2           2
           ds2 = r  del (theta) + del (r) + r  sin (theta) del (phi)

(%o2)                                done
</pre></div></div>

<p>The following example illustrates the conversion of the Rindler metric
to new coordinates that mimic the Schwarzschild metric.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) cords_in:[omega,rho]; 
(%o1)                            [omega, rho]
(%i2) cords_ot:[t,xi]; 
(%o2)                               [t, xi]
(%i3) cords_tr:[t/2,2*sqrt(xi)]; 
                                 t
(%o3)                           [-, 2 sqrt(xi)]
                                 2
(%i4) lg_in:matrix([-rho^2,0],[0,1]); 
                                 [      2    ]
(%o4)                            [ - rho   0 ]
                                 [           ]
                                 [   0     1 ]
(%i5) dg_metric(cnvrt); 
                                 2           2    2
                     ds2_in = del (rho) - rho  del (omega)

                                   2
                                del (xi)         2
                          ds2 = -------- - xi del (t)
                                   xi

(%o5)                                done
</pre></div></div>

<a class="anchor" id="dg_005fgrad"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fgrad"><span class="category-def">Function: </span><span><strong class="def-name">dg_grad</strong> <var class="def-var-arguments">(<code class="code">[1,2]</code>)</var><a class="copiable-link" href="#index-dg_005fgrad"> &para;</a></span></dt>
<dd><p>This function takes one argument. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>. The function
<code class="code">dg_grad</code> returns an expression for the gradient of a function
<code class="code">F</code> in the output coordinates <code class="code">cord_ot</code>.
</p>
<p>If the argument to <code class="code">dg_grad</code> is <code class="code">1</code>, then the gradient is
computed in the physical basis (found in most intro textbooks).  If the
argument is <code class="code">2</code> the gradient is computed in the coordinate basis.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(xyz_to_spher); 
(%o1)                                done
(%i2) dg_grad(1); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                  2    2             2       2    2           2
           ds2 = r  del (theta) + del (r) + r  sin (theta) del (phi)

gradient in physical basis 
                             dF             dF
                            ---- e_phi    ------ e_theta
                            dphi          dtheta           dF
(%o2)         dg_gra(F) := ------------ + -------------- + -- e_r
                           r sin(theta)         r          dr
</pre></div></div>

<a class="anchor" id="dg_005fcurl"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fcurl"><span class="category-def">Function: </span><span><strong class="def-name">dg_curl</strong> <var class="def-var-arguments">(<code class="code">[1,2]</code>)</var><a class="copiable-link" href="#index-dg_005fcurl"> &para;</a></span></dt>
<dd><p>This function takes one argument. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>. The curl function is
limited to <code class="code">d=3</code> dimensions. If the argument to <code class="code">dg_curl</code> is
<code class="code">1</code>, then the curl is computed in the physical basis (found in most
intro textbooks).  If the argument is <code class="code">2</code> the curl is computed in
the coordinate basis using the metric tensor.
</p>
<p>The function <code class="code">dg_curl</code> returns a function <code class="code">dg_cur(W)</code> that
takes vector argument <code class="code">W</code> and returns the curl in terms of the
output coordinates <code class="code">cord_ot</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(cart3d); 
(%o1)                                done
(%i2) dg_curl(1); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                                2         2         2
                       ds2 = del (z) + del (y) + del (x)

curl in physical basis 
                                 dW_z   dW_y  dW_x   dW_z  dW_y   dW_x
(%o2)  dg_cur(W_x, W_y, W_z) := [---- - ----, ---- - ----, ---- - ----]
                                  dy     dz    dz     dx    dx     dy
(%i3) dg_cords(xyz_to_cyl); 
(%o3)                                done
(%i4) dg_curl(1); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                             2         2       2    2
                    ds2 = del (z) + del (r) + r  del (phi)

curl in physical basis 
                                  dW_z
                                  ----
                                  dphi   dW_phi  dW_r   dW_z
(%o4) dg_cur(W_r, W_phi, W_z) := [---- - ------, ---- - ----, 
                                   r       dz     dz     dr
                                                         dW_r
                                                         ----
                                                         dphi   W_phi   dW_phi
                                                       - ---- + ----- + ------]
                                                          r       r       dr
</pre></div></div>

<a class="anchor" id="dg_005fdiverg"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fdiverg"><span class="category-def">Function: </span><span><strong class="def-name">dg_diverg</strong> <var class="def-var-arguments">(<code class="code">[1,2]</code>)</var><a class="copiable-link" href="#index-dg_005fdiverg"> &para;</a></span></dt>
<dd><p>This function takes one argument. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>. If the argument to
<code class="code">dg_diverg</code> is <code class="code">1</code>, then the divergence is computed in the
physical basis (found in most intro textbooks).  If the argument is
<code class="code">2</code> the divergence is computed in the coordinate basis using the
metric tensor.
</p>
<p>The function <code class="code">dg_diverg</code> returns a function <code class="code">dg_div(W)</code> that
takes argument <code class="code">W</code> and returns the divergence in terms of the
output coordinates <code class="code">cord_ot</code>. The function <code class="code">dg_metric</code> must be
called before calling <code class="code">dg_diverg</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_metric(init); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                             2         2       2    2
                    ds2 = del (z) + del (r) + r  del (phi)

(%o2)                                done
(%i3) dg_diverg(1); 
divergence in physical basis 
                                              dW_phi
                                              ------
                                        W_r    dphi    dW_z   dW_r
(%o3)        dg_div(W_r, W_phi, W_z) := --- + ------ + ---- + ----
                                         r      r       dz     dr
</pre></div></div>


<a class="anchor" id="dg_005flaplac"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005flaplac"><span class="category-def">Function: </span><span><strong class="def-name">dg_laplac</strong> <var class="def-var-arguments">( )</var><a class="copiable-link" href="#index-dg_005flaplac"> &para;</a></span></dt>
<dd><p>This function takes no arguments. The input and output coordinates and
the transformation functions must be defined beforehand for this
function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>.
</p>
<p>The function <code class="code">dg_laplac</code> returns a function <code class="code">dg_lap(W)</code> that
takes arument <code class="code">W</code> and returns the Laplacian in terms of the output
coordinates <code class="code">cord_ot</code>. The function <code class="code">dg_metric</code> must be called
before calling <code class="code">dg_laplac</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_metric(init); 
                                 2         2         2
                     ds2_in = del (z) + del (y) + del (x)

                             2         2       2    2
                    ds2 = del (z) + del (r) + r  del (phi)

(%o2)                                done
(%i3) dg_laplac(); 
                                          2
                                         d F
                                   dF   -----
                                   --       2    2     2
                                   dr   dphi    d F   d F
(%o3)                 dg_lap(F) := -- + ----- + --- + ---
                                   r      2       2     2
                                         r      dz    dr
</pre></div></div>


<a class="anchor" id="dg_005fffc"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fffc"><span class="category-def">Function: </span><span><strong class="def-name">dg_ffc</strong> <var class="def-var-arguments">(<var class="var">[constraint equations]</var>)</var><a class="copiable-link" href="#index-dg_005fffc"> &para;</a></span></dt>
<dd><p>Compute the frame field connections. The input and output coordinates
and the transformation functions must be defined beforehand for this
function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>.
</p>
<p>The function <code class="code">dg_ffc</code> computes the attitude matrix <code class="code">A</code>, the
connection coefficients in the matrix <code class="code">Omega</code>, and the dual 1-forms
in the array <code class="code">thi</code>. Any constraint equations given are imposed after
calculating the attitude matrix.
</p>
<p>The structural equations are computed by first computing the matrices
<code class="code">TT[i,j]: thi[i] . thi[j]</code>, and <code class="code">DD[i,j]: diff(Omega[i,j])</code>,
and then computing <code class="code">KK[i,j]</code> by solving
<var class="var">domega(i,j) = K th(i) * thi(j)</var>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(xyz_to_cyl); 
(%o1)                                done
(%i2) dg_ffc([r = 1]); 
(%o2)                                done
(%i3) A; 
                          [  cos(phi)   sin(phi)  0 ]
                          [                         ]
(%o3)                     [ - sin(phi)  cos(phi)  0 ]
                          [                         ]
                          [     0          0      1 ]
(%i4) Omega; 
                          [     0       del(phi)  0 ]
                          [                         ]
(%o4)                     [ - del(phi)     0      0 ]
                          [                         ]
                          [     0          0      0 ]
(%i5) thi; 
                                [   del(r)   ]
                                [            ]
(%o5)                           [ r del(phi) ]
                                [            ]
                                [   del(z)   ]
</pre></div></div>

<a class="anchor" id="dg_005fkill"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-dg_005fkill"><span class="category-def">Function: </span><span><strong class="def-name">dg_kill</strong> <var class="def-var-arguments">([none,show])</var><a class="copiable-link" href="#index-dg_005fkill"> &para;</a></span></dt>
<dd><p>The function <code class="code">dg_kill</code> computes the Killing equations. The metric
must be computed with <code class="code">dg_metric</code> before this function is called.
If called with <code class="code">dis=show</code> then the killing equations will be shown,
otherwise they can be accessed in the array <code class="code">killeq</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dg_cords(mink2d); 
(%o1)                                done
(%i2) dg_metric(init); 
                                      2         2
                          ds2_in = del (x) - del (t)

                                     2         2
                            ds2 = del (x) - del (t)

(%o2)                                done
(%i3) dg_kill(show); 
                                            d     t
                          killeq     = - 2 (-- (xi ))
                                1, 1        dt

                                    d     x    d     t
                       killeq     = -- (xi ) - -- (xi )
                             1, 2   dt         dx

                                           d     x
                           killeq     = 2 (-- (xi ))
                                 2, 2      dx

(%o3)                                done
</pre></div></div>


<a class="anchor" id="get_005fctensor_005fvars"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-get_005fctensor_005fvars"><span class="category-def">Function: </span><span><strong class="def-name">get_ctensor_vars</strong> <var class="def-var-arguments">( )</var><a class="copiable-link" href="#index-get_005fctensor_005fvars"> &para;</a></span></dt>
<dd><p>This command is used to set the <code class="code">dgeom</code> coordinate variables from
those defined in the <code class="code">ctensor</code> package.  This command sets the
<code class="code">dgeom</code> coordinate variable <code class="code">cord_ot</code> to the ctensor variable
<code class="code">ct_cords</code>. Then sets the lower indexed metric <code class="code">lg</code> to the
metric <code class="code">g</code>. The <code class="code">ctensor</code> package must be loaded and the
metric computed for this command to work.
</p></dd></dl>

<a class="anchor" id="set_005fctensor_005fvars"></a><dl class="first-deffn def-block">
<dt class="deffn def-line" id="index-set_005fctensor_005fvars"><span class="category-def">Function: </span><span><strong class="def-name">set_ctensor_vars</strong> <var class="def-var-arguments">([init,cnvrt])</var><a class="copiable-link" href="#index-set_005fctensor_005fvars"> &para;</a></span></dt>
<dd><p>This function takes as argument <var class="var">init</var> or <var class="var">cnvrt</var>. The input and
output coordinates and the transformation functions must be defined
beforehand for this function to work. See the function <a class="ref" href="#dg_005fcords">dg_cords</a>.
See <a class="ref" href="#dg_005fmetric">dg_metric</a> for a description of the options <var class="var">init</var> and
<var class="var">cnvrt</var>.  This command is used to set up the calculation of the
Christoffel symbols using the <code class="code">ctensor</code> package using the
coordinates and transformation functions from the <code class="code">dgeom</code>
package. The Christoffel symbols are the connections in the coordinate
frame, as opposed to the frame-field connection coefficients computed
using the function <code class="code">dg_ffc</code>. The function <code class="code">set_ctensor_vars</code>
sets the following <code class="code">ctensor</code> variables: <code class="code">cframe_flage:false</code>,
<code class="code">dim</code>, and calls <code class="code">ct_coordsys()</code>. The <code class="code">ctensor</code> package
must be loaded for this command to work.
</p></dd></dl>

<p>Example: Compute the Christoffel symbols for flat space in polar
coordinates.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) load(ctensor)$ 
(%i2) dg_cords(xy_to_polar); 
(%o2)                                done
(%i3) set_ctensor_vars(init); 
                                      2         2
                          ds2_in = del (y) + del (x)

                               2    2             2
                        ds2 = r  del (theta) + del (r)

               ctlist = [r cos(theta), r sin(theta), [r, theta]]

(%o3)                                done
(%i4) christof(mcs); 
                                     2      1
(%t4)                             mcs     = -
                                     1, 2   r

                                    1
(%t5)                            mcs     = - r
                                    2, 2

(%o5)                                done
</pre></div></div>


</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-dgeom" accesskey="n" rel="next">Introduction to package dgeom</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
