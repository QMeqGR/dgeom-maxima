/*
;;  This program is free software; you can redistribute it and/or modify 
;;  it under the terms of the GNU General Public License as published by         
;;  the Free Software Foundation; either version 2 of the License, or            
;;  (at your option) any later version.                                  

;;  This program is distributed in the hope that it will be useful,              
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of               
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                
;;  GNU General Public License for more details.         

;; DESCRIPTION package for Maxima.
*/

if get('dgeom,'dgeom_version)#false then error("Package dgeom already loaded!")$
put('dgeom,'0.1,'dgeom_version)$

load("dgeom.lisp") $
/* load the documentation */
load("dgeom-index.lisp")$
load("dgeom-index-html.lisp")$

/********************/
/* Global variables */
/********************/
dg_minkowski:1;
scrootg:0;
cords_ot:0;
lg:0; /* for compatibility with ctensor */
g:0;
dim:0;

/*******************/
/* tellsimp rules  */
/*******************/
/* The following rule institutes dd=0, so that diff(del(X))=0 */
matchdeclare(X,true,Y,true)$
tellsimpafter(Y*'diff(del(X),X,1)*del(X),0)$

/************************************/
/* NOTE: Always call dg_coords first!!!

cords_in is coordinates IN
cords_tr is the transformation
cords_ot is coordinates OUT

*/
dg_cords(crds):=block(
  dg_minkowski:1, /* set to 1 for all coordinate systems by default */
  if crds='cart2d then
   ( cords_in:[x,y],
     cords_tr:[x,y],
     cords_ot:[x,y] )
  else if crds='cart3d then
   ( cords_in:[x,y,z],
     cords_tr:[x,y,z],
     cords_ot:[x,y,z] )
  else if crds='xyz_to_spher then
   ( cords_in:[x,y,z],
     cords_tr:[r*sin(theta)*cos(phi),r*sin(theta)*sin(phi),r*cos(theta)],
     cords_ot:[r,theta,phi],
     assume(r>0,theta>0,theta<%pi) )
  else if crds='xyz_to_spher2 then
   ( cords_in:[x,y,z],
     cords_tr:[r*cos(phi)*cos(theta),r*cos(phi)*sin(theta),r*sin(phi)],
     cords_ot:[r,theta,phi],
     assume(r>0,phi>0,phi<%pi) )
  else if crds='xyz_to_pro_spher then
   ( cords_in:[x,y,z],
     cords_tr:[sinh(chi)*sin(theta)*cos(phi),sinh(chi)*sin(theta)*sin(phi),
               cosh(chi)*cos(theta)],
     cords_ot:[chi,theta,phi],
     assume(chi>0,theta>0,theta<%pi) )
  else if crds='txyz_to_spher then
   ( dg_minkowski: -1,
     cords_in:[t,x,y,z],
     cords_tr:[t,r*sin(theta)*cos(phi),r*sin(theta)*sin(phi),r*cos(theta)],
     cords_ot:[t,r,theta,phi],
     assume(r>0,theta>0,theta<%pi) )
   else if crds='xyz_to_cyl then
   ( cords_in:[x,y,z],
     cords_tr:[r*cos(phi),r*sin(phi),z],
     cords_ot:[r,phi,z],
     assume(r>0) )
   else if crds='xy_to_polar then
   ( cords_in:[x,y],
     cords_tr:[r*cos(theta),r*sin(theta)],
     cords_ot:[r,theta],
     assume(r>0) )
   else if crds='xy_to_exp1 then
   ( cords_in:[x,y],
     cords_tr:[s*exp(t),s*exp(-t)],
     cords_ot:[s,t],
     assume(t>0) )
   else if crds='xy_to_uv2 then
   ( cords_in:[x,y],
     cords_tr:[u,v^2],
     cords_ot:[u,v] )
   else if crds='mink2d then
   ( dg_minkowski: -1,
     cords_in:[t,x],
     cords_tr:[t,x],
     cords_ot:[t,x] )
   else if crds='mink4d then
   ( dg_minkowski: -1,
     cords_in:[t,x,y,z],
     cords_tr:[t,x,y,z],
     cords_ot:[t,x,y,z] )
   else if crds='rindler then
   ( dg_minkowski: -1,
     cords_in:[t,x],
     cords_tr:[rho*sinh(omega),rho*cosh(omega)],
     cords_ot:[omega,rho],
     assume(rho>0) )
   else
   ( print("The following predefined coordinate systems are available:"),
     print("  cart2d, cart3d, xyz_to_spher, xyz_to_pro_spher, xyz_to_spher2 txyz_to_spher"),    
     print("  xyz_to_cyl, xy_to_polar, xy_to_exp1, xy_to_uv2, mink2d, mink4d, rindler") ),
   done
)$

/****************/
/* run_checks() */
/****************/
run_checks():=block(
  if listp( cords_in )=false then (print("Must set cords_in !!"), return(false)),
  if listp( cords_tr )=false then (print("Must set cords_tr !!"), return(false)),
  if listp( cords_ot )=false then (print("Must set cords_ot !!"), return(false)),
  true
);

/**********************/
/*  set_ctensor_vars  */
/**********************/
set_ctensor_vars():=block([],
  run_checks(),
  cframe_flag:false,
  dim:length(cords_ot),
  ctlist:makelist(cords_tr[i],i,dim),
  ctlist:append(ctlist,[cords_ot]),
  dg_metric(init),
  ct_coordsys(ctlist),
  /* ct_coordsys constructs lg but doesn't simplify it */
  lg:trigsimp(lg),
  display(ctlist)
);

/**********************/
/*  get_ctensor_vars  */
/**********************/
get_ctensor_vars():=block([],
  cords_ot:ct_coords, cords_in:ct_coords, cords_tr:ct_coords,
  disp(cords_ot),
  lg:trigsimp(lg),
  g:lg,
  print("done")
);


/*****************/
/* show_cords()  */
/*****************/
show_cords():=block(
  if run_checks()=false then return("Coordinates not defined."),
  display(cords_in),
  display(cords_tr),
  display(cords_ot),
  display(dg_minkowski)
);

/************/
/* rowmag() */
/************/
/* function to return the magnitude of a row
of a matrix */
rowmag(M,n):=block([dim:length(M),i,j,mgsq:0],
    for i: 1 thru dim do
        mgsq: mgsq + M[n,i]^2,
    mgsq: trigsimp(mgsq),
    sqrt(mgsq)
);

/**************/
/* row_norm() */
/**************/
/* Normalize the rows of a matrix */
row_norm(M):=block([dim,rmag,R],
  dim:length(M),
  rmag:zeromatrix(1,dim),
  R:zeromatrix(dim,dim),

  for i: 1 thru dim do /* compute the row magnitudes */
    rmag[1,i]:rowmag(M,i),
  /* Normalize the row lengths */
  for i:1 thru dim do
    for j: 1 thru dim do
      if rmag[1,i]#0 then R[i,j]:M[i,j]/rmag[1,i],
  R
);

/*****************/
/* dg_jacobian() */
/*****************/
dg_jacobian():=block([N],
  run_checks(),
  N:length(cords_in),
  J:zeromatrix(N,N),
  Jinv:zeromatrix(N,N),
  
  /* construct the Jacobian matrix */
  for i: 1 thru N do
    for j: 1 thru N do
      J[i,j]: diff( cords_tr[i] , cords_ot[j] ),

  /* compute the inverse and transpose of J */
    Jinv: trigsimp( invert(J) ),
    Jt: trigsimp( transpose(J) ),
  done
);

/***************/
/* dg_derivs() */
/***************/
/*
Call dg_derivs to compute the partial derivatives
in the new coordinates.

Invoke the derivatives by...
d_dx( ev(d_dx(r),diff) ),diff;

*/
dg_derivs():=block([N],
  run_checks(),
  N:length(cords_in),
  dg_jacobian(),
  
  /* construct the differential operators */
  for i: 1 thru N do
    block([tmp],
      block([ffin:0,F],
        for j: 1 thru N do
        ffin: ffin + J[j,i] * 'diff(F,cords_ot[j]),
        ffin: trigsimp(ffin),
        tmp: cords_in[i],
        tmp: concat(d_d,tmp),
        /* display(tmp),
        display(ff), */
        define( funmake(tmp,[F]) , ffin) ),
      block([ffot:0,F],
        for j: 1 thru N do
        ffot: ffot + Jinv[j,i] * 'diff(F,cords_in[j]),
        ffot: trigsimp(ffot),
        tmp: cords_ot[i],
        tmp: concat(d_d,tmp),
        /* display(tmp),
        display(ff), */
        define( funmake(tmp,[F]) , ffot) )
     )
);

/*************/
/* dg_grad() */
/*************/
/* compute the gradient in new coords  */
dg_grad():=block([N,F,diffmx,T1,T2,hats],
  run_checks(),
  N:length(cords_in),
  diffmx:makelist( 'diff(F,cords_ot[i]),i,N),
  hats:makelist( concat(e_,cords_ot[i]),i,N),
  T1:makelist(0,i,N),
  dg_jacobian(),
  Jitn: transpose( row_norm(Jinv) ),
  for i: 1 thru N do
    for j:1 thru N do
      T1[i]:T1[i]+diffmx[j]*Jinv[j,i],
  T2:makelist(0,i,N),
  for i:1 thru N do
    for j:1 thru N do
      T2[i]:T2[i]+hats[j]*Jitn[i,j],
  /* display(T1,T2,hats), */
  gra: sum(T1[i]*T2[i],i,1,N),
  gra:trigsimp(gra),
  gra:expand(gra),
  define( funmake(dg_gra,[F]) , gra )
);


/***************/
/* dg_metric() */
/***************/
/*computes the metric in the new coordinates */
dg_metric(trn):=block([N],
  N: length(cords_in),

  /* if trn = init, assume the metric is trivial */
  if trn='init then block(
  ds2_in:0,
  ds2_in: dg_minkowski * diff(cords_in[1])^2, /* in case minkowski */
  for i: 2 thru N do ds2_in: ds2_in + diff(cords_in[i])^2,
  ds2_in: trigsimp(ds2_in)
  )
  else if trn='cnvrt then
  ds2_in: sum( sum( lg_in[i,j] * del(cords_in[i]) * del(cords_in[j]), i, 1, N ), j, 1, N)
  else print("argument must be init or cnvrt"),
  display(ds2_in),
  
  ds2:0,
  if trn='init then block(
    ds2: dg_minkowski * diff(cords_tr[1])^2, /* in case minkowski */
    for i: 2 thru N do ds2: ds2 + diff(cords_tr[i])^2 )
  else if trn='cnvrt then block(
    ds2_in: sum( sum( lg_in[i,j] * diff(cords_tr[i]) * diff(cords_tr[j]), i, 1, N ), j, 1, N),
    ds2: subst(map("=",cords_in,cords_tr),ds2_in)
  ),
  ds2:expand(ds2),
  for i:1 thru N do ds2:collectterms(ds2,del( args(cords_ot)[i] ) ),
  for i:1 thru N do ds2:substpart( trigsimp(part(ds2,i)), ds2,i),
  for i:1 thru N do ds2:substpart( trigsimp(part(ds2,i)), ds2,i), /* yes, do this twice */
  
  g: zeromatrix(N,N),
  for i: 1 thru N do
    for j: 1 thru N do
      g[i,j]: coeff( expand( ds2 ) , del(args(cords_ot)[i]) * del(args(cords_ot)[j]) ),
      g: trigsimp(g), lg:g,
      detg: determinant(g),
      if detg#0 then ug: g^^(-1) else error("g is singular!"),
      scrootg: sqrt( detg ),

  display( ds2 )
)$

/****************/
/* dg_diverg()  */
/****************/
/* Divergence in the new coordinates */
/* Need to call dg_metric(); first for this to work */
dg_diverg():=block([W,N,tolist:cords_ot,tmp],
  if scrootg=0 then dg_metric(init),
  N:length(tolist),
  for i: 1 thru N do ( W[i]: concat(W_, args(tolist)[i]),
    depends(W[i],tolist) ),
  Wlist: makelist( W[i],i,N),
  tmp: sum( diff(W[i],args(tolist)[i]) +
    diff(scrootg, args(tolist)[i]) / scrootg *W[i],i,1,N ),
  define( funmake(dg_div,Wlist), tmp )
);


/****************/
/* dg_laplac()  */
/****************/
/* Laplacian in the new coordinates */
/* Need to call dg_metric(); first for this to work */
dg_laplac():=block([F,N,tolist:cords_ot,tmp,M],
  if scrootg=0 then dg_metric(init),
  N:length(tolist),
  depends(F,tolist),
  M: zeromatrix(N,N),
  ginv: invert(g),
  for i: 1 thru N do
    for j: 1 thru N do
        M[i,j]: diff( scrootg * ginv[i,j] * diff(F, args(tolist)[j] ) ,
        args(tolist)[i] ) / scrootg,
      M: ratsimp(M),
      L: sum( sum( M[i,j], i, 1, N) , j, 1, N),
      L: trigsimp(L),
      L: ev(L, collectterms, ratsimp),
  define( funmake(dg_lap,[F]) , L )
);


/************/
/* dg_ffc() */
/************/
/*
This function takes three arguments:
    1. cfunc: Euclidean coordinate functions in terms of
        curvilinear coordinates or other coordinates.
    2. coords: A list of the new coordinates, e.g. r,theta,phi
    3. constraint equation(s) imposed after calculating
        the attitude matrix, e.g. [r=1]
The function ffc outputs:
    1. The attitude matrix in 'A'
    2. The connection coefficients in 'omega'
    3. The dual 1-forms in 'th'
*/

/* The rows of the matrix A are, e.g.:
d/dr=  dr/dx, dr/dy, dr/dz
d/dth= dth/dx, dth/dy, dth/dz,...
These need to be normalized to get the correct
connection coefficients. */

dg_ffc([seq]):=block([cfunc:cords_tr,coords:cords_ot,i,j,dA,rmag,dx,dim,Ktmp],
    dim:length(coords),
    A:zeromatrix(dim,dim),
    dA:zeromatrix(dim,dim),
    rmag:zeromatrix(1,dim),
    dx:zeromatrix(dim,1),
    TT:zeromatrix(dim,dim),
    DD:zeromatrix(dim,dim),
    KK:zeromatrix(dim,dim),
    
    for i: 1 thru dim do  /* compute the coordinate differentials */
        dx[i,1]: diff(cfunc[i]),
    
    for i: 1 thru dim do /*Â construct the attitude matrix */
        for j: 1 thru dim do
            A[i,j]: diff(cfunc[j],coords[i]),
    
    A:subst(seq,A), /* put in any restrictions here, e.g. r=1 */
    
    A:row_norm(A), /* normalize the rows */
    dA: matrixmap(diff,A),
    thi: trigsimp( A . dx ), /* these are the theta_i dual forms */
    Omega: trigsimp( dA . transpose(A) ),
    
    /* Compute the structural equations */
    for i: 1 thru dim do
      for j: 1 thru i do
        ( TT[i,j]:TT[j,i]:thi[i].thi[j],
          DD[i,j]:DD[j,i]:expand(diff(Omega[i,j])),
          KK[i,j]:KK[j,i]:rhs( solve(DD[i,j]=Ktmp*TT[i,j],Ktmp)[1]) ),

    done
)$

/*********************/
/*  dg_kill();       */
/*********************/
/* Compute the killing equations */
dg_kill(dis):=block([i,j,mu,nu,sg,dim:length(cords_ot)],
    declare_index_properties(xi,[postsuperscript]),
    killeq:zeromatrix(dim,dim),
    for mu: 1 thru dim do
        for nu: 1 thru dim do
            killeq[mu,nu]: sum(g[mu,sg]*'diff(xi[cords_ot[sg]],cords_ot[nu]),sg,1,dim)+
            sum(g[sg,nu]*'diff(xi[cords_ot[sg]],cords_ot[mu]),sg,1,dim)+
            sum(xi[cords_ot[sg]]*diff(g[mu,nu],cords_ot[sg]),sg,1,dim),
   if dis = show then
      for i:1 thru dim do
         for j:1 thru i do
            display(killeq[j,i])
)$
